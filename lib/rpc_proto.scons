Import("env")

assetsenv = env.Clone(
    tools=["fbt_assets"],
    FW_LIB_NAME="rpc_proto",
    ASSETS_WORK_DIR=env.Dir("."),
    ASSETS_SRC_DIR=env.Dir("#/assets").rdir(),
)
assetsenv.ApplyLibFlags()

_rpc_proto_dir = assetsenv.Dir("${ASSETS_SRC_DIR}/protobuf_rpc")

# Protobuf .proto -> .c + .h
proto_src = _rpc_proto_dir.glob("*.proto", source=True)
proto_options = _rpc_proto_dir.glob("*.options", source=True)
assert proto_src and proto_options
proto = assetsenv.ProtoBuilder(assetsenv["ASSETS_WORK_DIR"], proto_src)
assetsenv.Depends(proto, proto_options)
# Precious(proto)
assetsenv.Alias("proto", proto)


# Protobuf version meta
proto_ver = assetsenv.ProtoVerBuilder(
    "${ASSETS_WORK_DIR}/protobuf_version.h",
    _rpc_proto_dir.File("Changelog"),
)
assetsenv.Depends(proto_ver, proto)
assetsenv.Alias("proto_ver", proto_ver)

env.AppendUnique(
    CPPPATH=[
        assetsenv["ASSETS_WORK_DIR"],
        assetsenv["ASSETS_WORK_DIR"].Dir("compiled"),
    ]
)


headers = list(filter(lambda fn: fn.name.endswith(".h"), Flatten((proto, proto_ver))))
sources = list(
    filter(lambda fn: not fn.name.endswith(".h"), Flatten((proto, proto_ver)))
)

env.AppendUnique(
    FW_ASSETS_HEADERS=headers,
    FW_STATIC_ANALYSIS_DEPS=[proto, proto_ver],
)


lib = assetsenv.StaticLibrary("${FW_LIB_NAME}", sources)
assetsenv.Install("${LIB_DIST_DIR}", lib)
Return("lib")
